<!DOCTYPE html>
<html lang="en">
  <head>
    <title>BETA Live Template Editor · MAUL</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta property="og:title" content="BETA Live Template Editor · MAUL" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://moddedamong.us/BETAtemplates" />
    <meta property="og:image" content="https://moddedamong.us/images/banner.png" />
    <meta
      property="og:description"
      content="Type, style, and export Among Us templates in real time."
    />
    <meta property="og:site_name" content="Modded Among Us Lobbies" />
    <meta property="og:locale" content="en_US" />
    <link rel="canonical" href="https://moddedamong.us/BETAtemplates" />
    <link rel="shortcut icon" type="image/png" href="images/favicon.png" />
 
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Poppins:wght@500;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Barlow:wght@300;700;900&family=VT323&family=Roboto+Mono:wght@400;700&family=Orbitron:wght@500;700&family=Press+Start+2P&family=Share+Tech+Mono&family=Rajdhani:wght@700&family=Noto+Sans+JP:wght@400;700&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
      integrity="sha512-pcKRe3h4c9VBPlPfwDrLEkHZ90a4q/OzHD7S9vMYI9z1y9u2c7p7x5AcZx/9H84zYZlzGw8c47jM7TCtWbsxkA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    />

    <style>
      :root {
        --accent: #800000;
        --accent-soft: rgba(128, 0, 0, 0.25);
        --accent-strong: #b00000;
        --bg-card: rgba(30, 12, 12, 0.9);
        --bg-soft: rgba(45, 18, 18, 0.9);
        --text-main: #ffffff;
        --text-muted: #dedee8;
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        font-family: "Roboto", sans-serif;
        color: var(--text-main);
        overflow-x: hidden;
      }

      body {
        background: #000 url("images/maulredbg.png") no-repeat top center fixed;
        background-size: auto 100%;
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }

      body::before {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at top, rgba(128, 0, 0, 0.45), transparent 55%),
          radial-gradient(circle at bottom, rgba(180, 0, 60, 0.25), transparent 55%);
        mix-blend-mode: screen;
        opacity: 0.7;
        pointer-events: none;
        z-index: -2;
      }

      body::after {
        content: "";
        position: fixed;
        inset: 0;
        background: radial-gradient(circle at center, rgba(20, 0, 0, 0.75), rgba(5, 0, 0, 0.9));
        z-index: -1;
      }
 
      .dropdown {
        position: fixed;
        top: 18px;
        left: 18px;
        z-index: 100;
      }

      .dropbtn {
        background: rgba(35, 10, 10, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.14);
        cursor: pointer;
        transition: transform 0.25s ease, box-shadow 0.25s ease, background 0.25s ease;
        padding: 10px 10px;
        border-radius: 999px;
        backdrop-filter: blur(10px);
      }

      .dropbtn:hover {
        transform: translateY(-1px) scale(1.03);
        background: rgba(50, 16, 16, 0.98);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.7);
      }

      .hamburger {
        width: 26px;
        height: 18px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .hamburger span {
        display: block;
        height: 3px;
        background: linear-gradient(90deg, var(--accent), #ff0040);
        border-radius: 999px;
      }

      .dropdown-content {
        display: none;
        position: absolute;
        margin-top: 8px;
        background-color: rgba(35, 10, 10, 0.96);
        min-width: 220px;
        box-shadow: 0 16px 40px rgba(0, 0, 0, 0.85);
        border-radius: 12px;
        overflow: hidden;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .dropdown.open .dropdown-content {
        display: block;
      }

      .dropdown-content a {
        color: var(--text-main);
        padding: 12px 18px;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.95rem;
        transition: background 0.25s, color 0.25s, padding-left 0.25s;
      }

      .dropdown-content a:hover {
        background: rgba(255, 255, 255, 0.04);
        color: var(--accent);
        padding-left: 22px;
      }

      .beta-glow {
        color: #ff4d4d !important;
        font-weight: 700;
        text-shadow: 0 0 8px rgba(255, 0, 0, 0.75), 0 0 12px rgba(255, 0, 0, 0.55);
      }

      .page-wrapper {
        max-width: 1200px;
        width: 100%;
        margin: 0 auto 40px;
        padding: 80px 20px 0;
      }

      @media (max-width: 600px) {
        .page-wrapper {
          padding-top: 90px;
        }
      }

      .header {
        position: relative;
        text-align: center;
        padding: 40px 20px 20px;
      }

      .header-badge {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 999px;
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        background: linear-gradient(120deg, rgba(128, 0, 0, 0.5), rgba(200, 0, 80, 0.35));
        border: 1px solid rgba(255, 255, 255, 0.18);
        color: var(--text-muted);
        margin-bottom: 16px;
      }

      .header-badge-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: radial-gradient(circle, #00ff9c, #00b36b);
        box-shadow: 0 0 12px rgba(0, 255, 156, 0.7);
      }

      .header h1 {
        font-family: "Poppins", sans-serif;
        font-size: clamp(2.4rem, 4vw, 3.2rem);
        margin: 0;
        text-shadow: 0 8px 30px rgba(0, 0, 0, 0.9);
        letter-spacing: 0.04em;
      }

      .header h1 span {
        background: linear-gradient(135deg, #ff3b3b, var(--accent));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }

      .header-subtitle {
        max-width: 720px;
        margin: 14px auto 0;
        color: var(--text-muted);
        font-size: 0.95rem;
        line-height: 1.6;
      }

      .header-highlight {
        color: var(--accent);
        font-weight: 600;
      }

      .header-actions {
        margin-top: 24px;
        display: flex;
        justify-content: center;
        gap: 14px;
        flex-wrap: wrap;
      }

      .cta-primary,
      .cta-secondary {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 9px 16px;
        border-radius: 999px;
        text-decoration: none;
        font-size: 0.9rem;
        cursor: pointer;
        transition: background 0.2s ease, border-color 0.2s ease, transform 0.18s ease,
          box-shadow 0.18s ease, filter 0.18s ease;
      }

      .cta-primary {
        padding: 10px 18px;
        background: linear-gradient(135deg, #800000, #b00000);
        color: #ffffff;
        font-weight: 600;
        font-size: 0.95rem;
        box-shadow: 0 10px 26px rgba(0, 0, 0, 0.9);
      }

      .cta-secondary {
        border: 1px solid rgba(255, 255, 255, 0.22);
        background: rgba(40, 12, 12, 0.9);
        color: var(--text-muted);
      }

      .cta-secondary:hover {
        background: rgba(55, 18, 18, 0.98);
        border-color: var(--accent-soft);
        transform: translateY(-1px);
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.9);
      }

      .cta-primary:hover {
        transform: translateY(-1px);
        box-shadow: 0 14px 34px rgba(0, 0, 0, 0.95);
        filter: brightness(1.05);
      }

      .info-paragraph {
        font-size: 0.98rem;
        line-height: 1.7;
        background: var(--bg-card);
        padding: 22px 24px;
        border-radius: 16px;
        max-width: 900px;
        margin: 28px auto 20px;
        text-align: left;
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }

      .info-paragraph strong {
        color: var(--accent);
        font-weight: 600;
      }

      .content-grid {
        max-width: 1100px;
        width: 100%;
        margin: 0 auto 40px;
        padding: 0 20px 10px;
        display: grid;
        gap: 22px;
      }

      .panel {
        background: var(--bg-card);
        border-radius: 20px;
        padding: 22px 22px 24px;
        border: 1px solid rgba(255, 255, 255, 0.08);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.95);
        backdrop-filter: blur(14px);
      }

      .section-title {
        font-size: 1.7rem;
        margin: 0 0 6px;
        text-align: center;
        letter-spacing: 0.12em;
        text-transform: uppercase;
      }

      .section-subtitle {
        text-align: center;
        color: var(--text-muted);
        margin: 0 0 18px;
        font-size: 0.9rem;
      }

      @media (max-width: 700px) {
        .content-grid {
          padding: 0 14px 10px;
        }
        .page-wrapper {
          padding-top: 80px;
        }
      }

      /* Controls */
      .tool-wrap {
        display: grid;
        gap: 14px;
      }

      .tool-controls {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        align-items: center;
      }

      .tool-controls .field {
        display: flex;
        align-items: center;
        gap: 8px;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.16);
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 0.85rem;
        color: var(--text-muted);
      }

      .tool-controls input[type="text"],
      .tool-controls input[type="number"],
      .tool-controls select,
      .tool-controls textarea {
        background: rgba(0, 0, 0, 0.6);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        color: #def;
        padding: 6px 8px;
        outline: none;
      }

      .btn {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.22);
        color: #e7f0ff;
        font-size: 0.9em;
        padding: 7px 12px;
        border-radius: 999px;
        cursor: pointer;
        transition: background 0.2s, border-color 0.2s, transform 0.02s, box-shadow 0.2s;
        user-select: none;
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.12);
        border-color: rgba(255, 255, 255, 0.3);
        box-shadow: 0 8px 18px rgba(0, 0, 0, 0.8);
      }

      .btn:active {
        transform: scale(0.98);
      }

      .btn.primary {
        background: linear-gradient(135deg, #800000, #b00000);
        border: 1px solid rgba(255, 255, 255, 0.14);
      }

      .btn.primary:hover {
        filter: brightness(1.05);
      }

      .split {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
      }

      @media (max-width: 900px) {
        .split {
          grid-template-columns: 1fr;
        }
      }

      .codebox {
        display: grid;
        gap: 8px;
      }

      .codebox code,
      .codebox pre {
        display: block;
        background: rgba(0, 0, 0, 0.7);
        border: 1px solid rgba(255, 255, 255, 0.22);
        border-radius: 12px;
        padding: 10px;
        white-space: pre-wrap;
        word-break: break-word;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
        font-size: 0.85rem;
        margin: 0;
      }

      .preview {
        padding: 12px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.18);
        min-height: 80px;
      }

      .preview span {
        display: inline-block;
      }

      .stops {
        display: grid;
        gap: 8px;
        margin-top: 6px;
      }

      .stop-row {
        display: grid;
        grid-template-columns: 120px 1fr 140px;
        gap: 8px;
        align-items: center;
        background: rgba(255, 255, 255, 0.04);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 12px;
        padding: 8px;
      }

      @media (max-width: 760px) {
        .stop-row {
          grid-template-columns: 120px 1fr;
        }
        .stop-row .row-btns {
          grid-column: 1 / -1;
          display: flex;
          gap: 8px;
          justify-content: flex-end;
        }
      }

      .stop-row input[type="color"] {
        width: 42px;
        height: 32px;
        border: none;
        background: transparent;
        padding: 0;
        cursor: pointer;
      }

      .grad-preview {
        height: 44px;
        border-radius: 8px;
        border: 1px solid #000;
        margin: 8px 0;
      }

      .status {
        font-size: 0.9rem;
        color: var(--text-muted);
        min-height: 1.2em;
      }

      /* Icons palette */
      .icon-palette {
        display: none;
        margin-top: 10px;
        background: rgba(0, 0, 0, 0.65);
        border: 1px solid rgba(255, 255, 255, 0.22);
        border-radius: 12px;
        padding: 10px;
        max-height: 220px;
        overflow: auto;
      }
      .icon-palette.open {
        display: block;
      }
      .icon-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }
      .icon-grid button {
        min-width: 34px;
        padding: 6px 10px;
      }

      /* Popup / modal */
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        padding: 18px;
        z-index: 999;
      }
      .modal.open {
        display: flex;
      }
      .modal-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.72);
        backdrop-filter: blur(6px);
      }
      .modal-card {
        position: relative;
        max-width: 760px;
        width: 100%;
        background: rgba(35, 10, 10, 0.96);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 18px;
        box-shadow: 0 22px 60px rgba(0, 0, 0, 0.9);
        padding: 18px 18px 16px;
      }
      .modal-title {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
      }
      .modal-title h3 {
        margin: 0;
        font-family: "Poppins", sans-serif;
        letter-spacing: 0.05em;
      }
      .modal-title h3 span {
        background: linear-gradient(135deg, #ff3b3b, var(--accent));
        -webkit-background-clip: text;
        background-clip: text;
        color: transparent;
      }
      .modal-body {
        color: var(--text-muted);
        line-height: 1.6;
        font-size: 0.95rem;
      }
      .modal-body code {
        background: rgba(0, 0, 0, 0.55);
        border: 1px solid rgba(255, 255, 255, 0.14);
        padding: 1px 6px;
        border-radius: 8px;
        color: #def;
      }
      .modal-actions {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        margin-top: 12px;
        flex-wrap: wrap;
      }
      .modal-actions label {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: var(--text-muted);
        font-size: 0.9rem;
        user-select: none;
      }

      footer {
        width: 100%;
        display: flex;
        justify-content: center;
        margin: 40px 0 30px;
        padding: 0 16px;
      }

      .footer-inner {
        max-width: 900px;
        width: 100%;
        text-align: center;
        padding: 18px 24px;
        border-radius: 18px;
        background: radial-gradient(circle at top, rgba(255, 255, 255, 0.06), transparent 55%),
          linear-gradient(135deg, #240404, #0b0000);
        border: 1px solid rgba(255, 255, 255, 0.12);
        box-shadow: 0 18px 40px rgba(0, 0, 0, 0.9);
        font-size: 0.9rem;
        color: var(--text-muted);
      }

      .footer-inner a {
        color: var(--accent-strong);
        text-decoration: none;
        font-weight: 600;
      }

      .footer-inner a:hover {
        color: #ff0000;
        text-decoration: underline;
      }
    </style>
  </head>

  <body>
    <!-- NAV (copied from tags page) -->
    <div class="dropdown">
      <button class="dropbtn" type="button" aria-label="Open navigation menu">
        <div class="hamburger">
          <span></span>
          <span></span>
          <span></span>
        </div>
      </button>
      <div class="dropdown-content">
        <a href="https://moddedamong.us/"><i class="fa-solid fa-house"></i> Home</a>
        <a href="https://moddedamong.us/art.html"><i class="fa-solid fa-paintbrush"></i> User Art</a>
        <a href="https://moddedamong.us/ourstaff.html"><i class="fa-solid fa-users-gear"></i> Our Staff</a>
        <a href="https://moddedamong.us/eventpics.html"><i class="fa-regular fa-images"></i> Past Events</a>
        <a href="https://moddedamong.us/calendar.html"><i class="fa-regular fa-calendar"></i> Event Calendar</a>
        <a href="https://moddedamong.us/mods.html"><i class="fa-solid fa-code-branch"></i> Featured Mods</a>
        <a href="https://moddedamong.us/presets.html"><i class="fa-solid fa-sliders"></i> Mod Presets</a>
        <a href="https://moddedamong.us/tags.html"><i class="fa-solid fa-ticket"></i> Tag Generator</a>
        <a href="https://moddedamong.us/icons.html"><i class="fa-regular fa-face-smile"></i> Icons and Fonts</a>
        <a href="https://moddedamong.us/lobbytemplates"><i class="fa-solid fa-list"></i> Lobby Templates</a>
        <a href="https://moddedamong.us/wrapped"
          ><i class="fa-solid fa-gift"></i> <span class="beta-glow">NEW</span> – 2025 Wrapped</a
        >
        <a href="https://moddedamong.us/roletest"
          ><i class="fa-solid fa-brain"></i> <span class="beta-glow">NEW</span> – Personality Test</a
        >
        <a href="https://moddedamong.us/BETAtemplates" class="beta-glow"
          ><i class="fa-solid fa-flask"></i> BETA Templates</a
        >
      </div>
    </div>
 
    <div class="modal" id="betaModal" aria-hidden="true">
      <div class="modal-backdrop" id="betaModalBackdrop"></div>
      <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="betaModalTitle">
        <div class="modal-title">
          <h3 id="betaModalTitle"><span>Important</span> – Read before using</h3>
          <button class="btn" type="button" id="betaModalClose" aria-label="Close popup">✕</button>
        </div>
        <div class="modal-body">
          <p style="margin: 0 0 10px">
            This tool is <strong class="beta-glow">BETA</strong>. A few rules to keep your template clean:
          </p>
          <ul style="margin: 0 0 10px; padding-left: 18px">
            <li>
              New lines export as literal <code>\n</code>. You can insert one with the <strong>↵ \n</strong> button.
            </li>
            <li>
              Gradients apply only to <strong>real characters</strong> — they skip tokens like <code>{{PlayerName}}</code>
              and they skip the literal <code>\n</code>.
            </li>
            <li>
              Markup output is kept <strong>compact</strong>: base tags wrap the line, and only the pieces that change
              (like per-char colors in a gradient) get extra tags.
            </li>
          </ul>
          <p style="margin: 0">
            If something looks odd, hit <strong>Normalize output</strong> or re-apply a style to the selection.
          </p>
        </div>
        <div class="modal-actions">
          <label>
            <input type="checkbox" id="dontShowAgain" />
            Don’t show this again
          </label>
          <button class="btn primary" type="button" id="betaModalOk">Got it</button>
        </div>
      </div>
    </div>

    <div class="page-wrapper">
      <div class="header">
        <div class="header-badge">
          <span class="header-badge-dot"></span>
          Template tools for MAUL lobbies
        </div>

        <h1><span>MAUL Live Template Editor</span></h1>

        <p class="header-subtitle">
          Build <span class="header-highlight">multi-line lobby templates</span> with fonts, sizes, bold/italic/underline,
          solid color, and gradients. Copy the output and paste it directly into your config.
        </p>

        <div class="header-actions">
          <a href="https://moddedamong.us/" class="cta-secondary">
            <i class="fa-solid fa-arrow-left"></i>
            Back to Home
          </a>
          <a href="https://moddedamong.us/icons.html" class="cta-primary">
            <i class="fa-regular fa-face-smile"></i>
            Icons &amp; Fonts
          </a>
        </div>
      </div>

      <p class="info-paragraph">
        Live editor that keeps markup <strong>clean and stable</strong> while you type. Select text to style it, then copy
        the export. Tokens like <code>{{PlayerName}}</code> stay untouched.
      </p>

      <main class="content-grid">
        <section class="panel">
          <h2 class="section-title"><u>BETA Live Template Editor</u></h2>
          <p class="section-subtitle">
            Type on the left, preview + export on the right. (Preview is a web approximation.)
          </p>

          <div class="tool-wrap">
            <!-- CONTROLS -->
            <div class="tool-controls">
              <div class="field">
                <strong>Font</strong>
                <select id="fontSel">
                  <option>OCRAXT SDF</option>
                  <option>BROOK SDF</option>
                  <option>VCR SDF</option>
                  <option>Barlow-Black SDF</option>
                  <option>Barlow-BoldItalic SDF</option>
                  <option>Barlow-Light SDF</option>
                  <option>CONSOLA SDF</option>
                  <option>DIGITAL-7 SDF</option>
                  <option>DIN_Pro_Bold_700 SDF</option>
                  <option>LiberationSans SDF</option>
                  <option>NotoSansJP-Regular SDF</option>
                  <option>OCRAEXT SDF</option>
                </select>
                <button class="btn" id="applyFont" type="button">Apply</button>
              </div>

              <div class="field">
                <strong>Size %</strong>
                <input id="sizePct" type="number" min="50" max="300" step="5" value="100" style="width: 84px" />
                <button class="btn" id="applySize" type="button">Apply</button>
              </div>

              <div class="field">
                <strong>Style</strong>
                <button class="btn" id="btnB" type="button"><strong>B</strong></button>
                <button class="btn" id="btnI" type="button"><em>I</em></button>
                <button class="btn" id="btnU" type="button"><u>U</u></button>
                <button class="btn" id="btnNL" type="button">↵ \n</button>
                <button class="btn" id="btnUndo" type="button">Undo</button>
                <button class="btn" id="btnRedo" type="button">Redo</button>
              </div>

              <div class="field">
                <strong>Align</strong>
                <button class="btn" type="button" data-align="left">Left</button>
                <button class="btn" type="button" data-align="center">Center</button>
                <button class="btn" type="button" data-align="right">Right</button>
              </div>

              <div class="field">
                <strong>Solid</strong>
                <input id="solidColor" type="color" value="#FFFFFF" />
                <button class="btn" id="applySolid" type="button">Apply</button>
              </div>

              <div class="field">
                <strong>Token</strong>
                <select id="tokenSel" style="min-width: 170px">
                  <option value="{{PlayerName}}">{{PlayerName}}</option>
                  <option value="{{HostName}}">{{HostName}}</option>
                  <option value="{{ModVersion}}">{{ModVersion}}</option>
                </select>
                <button class="btn" id="insertToken" type="button">Insert</button>
              </div>

              <div class="field">
                <strong>Line</strong>
                <label style="display: flex; align-items: center; gap: 6px">
                  <input type="checkbox" id="applyLine" />
                  Apply to line
                </label>
                <button class="btn" id="resetLine" type="button">Reset</button>
              </div>

              <div class="field">
                <strong>New line</strong>
                <label style="display: flex; align-items: center; gap: 6px">
                  <input type="checkbox" id="cleanSlate" checked />
                  Clean slate
                </label>
              </div>

              <div class="field">
                <strong>Icons</strong>
                <button class="btn" id="toggleIcons" type="button">Palette</button>
                <label style="display: flex; align-items: center; gap: 6px">
                  <input type="checkbox" id="safeIcons" checked />
                  Safe only
                </label>
              </div>

              <div class="field">
                <strong>Tools</strong>
                <button class="btn" id="clearStyles" type="button">Clear selection</button>
                <button class="btn" id="normalize" type="button">Normalize output</button>
              </div>
            </div>

            <!-- ICONS -->
            <div class="icon-palette" id="iconPalette" aria-label="Icon palette">
              <div class="icon-grid" id="iconGrid"></div>
            </div>

            <!-- GRADIENT -->
            <div class="tool-controls" style="justify-content: space-between">
              <div class="field">
                <strong>Gradient</strong>
                <button class="btn" id="addStop" type="button">Add stop</button>
                <button class="btn" id="remStop" type="button">Remove stop</button>
                <button class="btn" id="randStops" type="button">Randomize</button>
              </div>
              <div class="field">
                <button class="btn primary" id="applyGradient" type="button">
                  <i class="fa-solid fa-wand-magic-sparkles"></i>
                  Apply gradient
                </button>
              </div>
            </div>

            <div class="grad-preview" id="gradPreview" aria-label="Gradient preview"></div>
            <div class="stops" id="stops"></div>

            <!-- EDITOR / OUTPUT -->
            <div class="split">
              <div class="codebox">
                <textarea id="editor" style="min-height: 220px" spellcheck="false"></textarea>

                <div class="tool-controls" style="justify-content: space-between">
                  <div style="display: flex; gap: 10px; flex-wrap: wrap">
                    <button class="btn primary" id="copyMarkup" type="button">Copy markup</button>
                    <button class="btn" id="downloadTxt" type="button">Download .txt</button>
                  </div>
                  <div class="status" id="status" aria-live="polite"></div>
                </div>

                <pre><code id="output"></code></pre>
              </div>

              <div class="codebox">
                <div class="tool-controls" style="justify-content: space-between">
                  <div class="field" style="flex: 1">
                    <strong>Preview</strong>
                    <span style="opacity: 0.9">Web font approximations only.</span>
                  </div>
                </div>

                <div class="preview" id="preview"></div>
              </div>
            </div>
          </div>
        </section>
      </main>

      <footer>
        <div class="footer-inner">
          <p>Made with ♥ by MAUL</p>
        </div>
      </footer>
    </div>

    <script>
      // Dropdown menu (same logic as tags page)
      document.addEventListener("DOMContentLoaded", () => {
        const dropdown = document.querySelector(".dropdown");
        const button = document.querySelector(".dropbtn");
        if (!dropdown || !button) return;

        button.addEventListener("click", (e) => {
          e.stopPropagation();
          dropdown.classList.toggle("open");
        });

        document.addEventListener("click", (e) => {
          if (!dropdown.contains(e.target)) dropdown.classList.remove("open");
        });
      });
    </script>

    <script>
      /* ============================================================
         Engine:
         - keeps markup COMPACT (no repeating align/font/size per char)
         - gradient only changes <color> as needed
         - tokens {{...}} and literal \n are not styled by gradient
         ============================================================ */

      function copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) return navigator.clipboard.writeText(text);
        const ta = document.createElement("textarea");
        ta.value = text;
        ta.style.position = "fixed";
        ta.style.left = "-9999px";
        document.body.appendChild(ta);
        ta.select();
        try {
          document.execCommand("copy");
        } finally {
          document.body.removeChild(ta);
        }
        return Promise.resolve();
      }

      const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
      const normHex = (s, withHash = true) => {
        s = (s || "").trim();
        if (!s) return withHash ? "#FFFFFF" : "FFFFFF";
        s = s.replace(/^#/, "").replace(/[^0-9a-fA-F]/g, "").slice(0, 6);
        if (s.length === 3) s = s.split("").map((c) => c + c).join("");
        if (s.length < 6) s = (s + "FFFFFF").slice(0, 6);
        return (withHash ? "#" : "") + s.toUpperCase();
      };

      const hexToRgb = (h) => {
        h = normHex(h, true).slice(1);
        return { r: parseInt(h.slice(0, 2), 16), g: parseInt(h.slice(2, 4), 16), b: parseInt(h.slice(4, 6), 16) };
      };
      const rgbToHex = ({ r, g, b }) =>
        "#" + [r, g, b].map((x) => clamp(x | 0, 0, 255).toString(16).padStart(2, "0")).join("").toUpperCase();
      const lerp = (a, b, t) => a + (b - a) * t;
      const lerpColor = (h1, h2, t) => {
        const c1 = hexToRgb(h1),
          c2 = hexToRgb(h2);
        return rgbToHex({ r: lerp(c1.r, c2.r, t), g: lerp(c1.g, c2.g, t), b: lerp(c1.b, c2.b, t) });
      };

      const FONT_MAP = {
        "VCR SDF": '"VT323", monospace',
        "Barlow-Black SDF": '"Barlow", sans-serif',
        "Barlow-BoldItalic SDF": '"Barlow", sans-serif',
        "Barlow-Light SDF": '"Barlow", sans-serif',
        "BROOK SDF": '"Rajdhani", sans-serif',
        "CONSOLA SDF": '"Roboto Mono", monospace',
        "DIGITAL-7 SDF": '"Orbitron", monospace',
        "DIN_Pro_Bold_700 SDF": '"Rajdhani", sans-serif',
        "LiberationSans SDF": '"Roboto", sans-serif',
        "NotoSansJP-Regular SDF": '"Noto Sans JP", sans-serif',
        "OCRAEXT SDF": '"Share Tech Mono", monospace',
        "OCRAXT SDF": '"Share Tech Mono", "VT323", monospace'
      };

      const $ = (id) => document.getElementById(id);

      // UI refs
      const editor = $("editor");
      const output = $("output");
      const preview = $("preview");
      const status = $("status");

      const fontSel = $("fontSel");
      const sizePct = $("sizePct");
      const solidColor = $("solidColor");

      const applyFontBtn = $("applyFont");
      const applySizeBtn = $("applySize");
      const applySolidBtn = $("applySolid");

      const btnB = $("btnB");
      const btnI = $("btnI");
      const btnU = $("btnU");
      const btnNL = $("btnNL");
      const btnUndo = $("btnUndo");
      const btnRedo = $("btnRedo");

      const applyLine = $("applyLine");
      const resetLineBtn = $("resetLine");
      const cleanSlate = $("cleanSlate");

      const tokenSel = $("tokenSel");
      const insertTokenBtn = $("insertToken");

      const toggleIconsBtn = $("toggleIcons");
      const safeIcons = $("safeIcons");
      const iconPalette = $("iconPalette");
      const iconGrid = $("iconGrid");

      const clearStylesBtn = $("clearStyles");
      const normalizeBtn = $("normalize");

      const addStopBtn = $("addStop");
      const remStopBtn = $("remStop");
      const randStopsBtn = $("randStops");
      const gradPreview = $("gradPreview");
      const stopsEl = $("stops");
      const applyGradientBtn = $("applyGradient");

      const copyMarkupBtn = $("copyMarkup");
      const downloadTxtBtn = $("downloadTxt");

      // Modal refs
      const betaModal = $("betaModal");
      const betaModalBackdrop = $("betaModalBackdrop");
      const betaModalClose = $("betaModalClose");
      const betaModalOk = $("betaModalOk");
      const dontShowAgain = $("dontShowAgain");

      const setStatus = (m) => (status.textContent = m || "");

      // Modal logic
      function openModal() {
        betaModal.classList.add("open");
        betaModal.setAttribute("aria-hidden", "false");
      }
      function closeModal() {
        if (dontShowAgain.checked) localStorage.setItem("maul_beta_modal_hide", "1");
        betaModal.classList.remove("open");
        betaModal.setAttribute("aria-hidden", "true");
      }
      betaModalBackdrop.addEventListener("click", closeModal);
      betaModalClose.addEventListener("click", closeModal);
      betaModalOk.addEventListener("click", closeModal);

      // Token parsing rules
      const isTokenStart = (str, i) => str[i] === "{" && str[i + 1] === "{";
      const readToken = (str, i) => {
        const k = str.indexOf("}}", i + 2);
        return k === -1 ? null : { start: i, end: k + 2 };
      };
      const isLiteralNL = (str, i) => str[i] === "\\" && str[i + 1] === "n";

      function buildVisibleMap(text) {
        const visToEdit = [];
        const editToVis = new Int32Array(text.length + 1);
        let v = 0;
        let i = 0;
        while (i < text.length) {
          editToVis[i] = v;

          if (isLiteralNL(text, i)) {
            i += 2;
            continue;
          }
          if (text[i] === "\n" || text[i] === "\r") {
            i++;
            continue;
          }

          if (isTokenStart(text, i)) {
            const tok = readToken(text, i);
            if (tok) {
              i = tok.end;
              continue;
            }
          }

          visToEdit.push(i);
          v++;
          i++;
        }
        editToVis[text.length] = v;
        return { visToEdit, editToVis, visLen: v };
      }

      const DEFAULTS = {
        color: "#FFFFFF",
        b: false,
        i: false,
        u: false,
        size: 100,
        font: "OCRAXT SDF",
        align: "left"
      };

      let TEXT = "";
      let MAP = buildVisibleMap("");
      let STYLE = { color: [], b: [], i: [], u: [], size: [], font: [], align: [] };

      function ensureStyleLength(n) {
        for (const k of Object.keys(STYLE)) {
          if (STYLE[k].length < n) {
            const fill =
              k === "color"
                ? DEFAULTS.color
                : k === "b" || k === "i" || k === "u"
                ? false
                : k === "size"
                ? DEFAULTS.size
                : k === "font"
                ? DEFAULTS.font
                : k === "align"
                ? DEFAULTS.align
                : null;
            while (STYLE[k].length < n) STYLE[k].push(fill);
          } else if (STYLE[k].length > n) {
            STYLE[k].length = n;
          }
        }
      }

      function getSelectionEditRange() {
        let s = editor.selectionStart | 0,
          e = editor.selectionEnd | 0;
        if (applyLine.checked) {
          const val = editor.value;
          const lineStart = val.lastIndexOf("\n", s - 1) + 1;
          const nextNL = val.indexOf("\n", e);
          const lineEnd = nextNL === -1 ? val.length : nextNL;
          s = lineStart;
          e = lineEnd;
          editor.selectionStart = s;
          editor.selectionEnd = e;
        }
        return { s, e };
      }

      function getSelectionVisibleRange() {
        const { s, e } = getSelectionEditRange();
        const vs = MAP.editToVis[clamp(s, 0, TEXT.length)];
        const ve = MAP.editToVis[clamp(e, 0, TEXT.length)];
        return { vs, ve };
      }

      // Undo/redo snapshots
      const MAX_HIST = 60;
      let undoStack = [],
        redoStack = [];

      function snapshot() {
        return {
          text: TEXT,
          style: {
            color: [...STYLE.color],
            b: [...STYLE.b],
            i: [...STYLE.i],
            u: [...STYLE.u],
            size: [...STYLE.size],
            font: [...STYLE.font],
            align: [...STYLE.align]
          },
          stops: STOPS.slice(),
          solid: normHex(solidColor.value, true),
          fontSel: fontSel.value,
          sizeCtl: parseInt(sizePct.value || "100", 10),
          cleanSlate: !!cleanSlate.checked
        };
      }

      function restore(s) {
        TEXT = s.text;
        editor.value = TEXT;
        MAP = buildVisibleMap(TEXT);
        STYLE = s.style;
        ensureStyleLength(MAP.visLen);

        STOPS = (s.stops && s.stops.length ? s.stops : STOPS).map((x) => normHex(x, true));
        solidColor.value = normHex(s.solid || "#FFFFFF", true);
        fontSel.value = s.fontSel || fontSel.value;
        sizePct.value = s.sizeCtl || sizePct.value;
        cleanSlate.checked = !!s.cleanSlate;

        renderStops();
        renderAll();
      }

      function pushHistory() {
        undoStack.push(snapshot());
        if (undoStack.length > MAX_HIST) undoStack.shift();
        redoStack.length = 0;
      }

      function undo() {
        if (!undoStack.length) return;
        redoStack.push(snapshot());
        restore(undoStack.pop());
        setStatus("Undone.");
      }

      function redo() {
        if (!redoStack.length) return;
        undoStack.push(snapshot());
        restore(redoStack.pop());
        setStatus("Redone.");
      }

      // Gradient stops
      let STOPS = ["#FF0033", "#FF4D79", "#FF7219", "#FFEB0C", "#00EAF0", "#7F00FF"].map((h) => normHex(h, true));

      function randHex() {
        return (
          "#" + Array.from({ length: 6 }, () => "89ABCDEF01234567"[Math.floor(Math.random() * 16)]).join("")
        );
      }

      function updateGradPreview() {
        const css = `linear-gradient(90deg, ${STOPS
          .map((c, i) => `${normHex(c, true)} ${(i * 100) / Math.max(STOPS.length - 1, 1)}%`)
          .join(", ")})`;
        gradPreview.style.background = css;
      }

      function renderStops() {
        stopsEl.innerHTML = "";
        STOPS.forEach((hex, idx) => {
          const row = document.createElement("div");
          row.className = "stop-row";
          row.innerHTML = `
            <div class="color" style="min-width:120px"><label>Stop ${idx + 1}</label></div>
            <div class="color" style="display:flex;align-items:center;gap:8px">
              <input type="text" value="${normHex(hex, true)}" aria-label="Hex stop ${idx + 1}">
              <input type="color" value="${normHex(hex, true)}" aria-label="Pick stop ${idx + 1}">
            </div>
            <div class="row-btns" style="display:flex;gap:8px;justify-content:flex-end;">
              <button class="btn stop-up" data-idx="${idx}" type="button" title="Up">▲</button>
              <button class="btn stop-down" data-idx="${idx}" type="button" title="Down">▼</button>
              <button class="btn stop-del" data-idx="${idx}" type="button" title="Remove">✕</button>
            </div>
          `;
          stopsEl.appendChild(row);
        });
        updateGradPreview();
      }

      // Icons
      const ICONS_SAFE = [
        "✿",
        "❀",
        "❖",
        "★",
        "☆",
        "✓",
        "∞",
        "☯",
        "⚠",
        "♥",
        "♡",
        "♦",
        "♣",
        "♠",
        "→",
        "←",
        "↑",
        "↓",
        "↔",
        "↕",
        "◉",
        "○",
        "◎",
        "●",
        "◯",
        "◇",
        "◆",
        "◈",
        "■",
        "□",
        "▪",
        "▫",
        "░",
        "▒",
        "▓",
        "█"
      ];
      const ICONS_FULL = [
        "✿",
        "❀",
        "❖",
        "⚽",
        "⚾",
        "♠",
        "♣",
        "♦",
        "♥",
        "♤",
        "♧",
        "♢",
        "♡",
        "☯",
        "✚",
        "⚠",
        "†",
        "∞",
        "✓",
        "☎",
        "☏",
        "☀",
        "☁",
        "☂",
        "☃",
        "★",
        "☆",
        "✽",
        "↑",
        "↓",
        "→",
        "←",
        "↔",
        "↕",
        "⚙",
        "⚡",
        "♩",
        "♪",
        "♫",
        "♬",
        "░",
        "▒",
        "▓",
        "█",
        "▪",
        "▫",
        "◆",
        "◣",
        "◥",
        "◤",
        "◢"
      ];

      function buildIcons() {
        iconGrid.innerHTML = "";
        const src = safeIcons.checked ? ICONS_SAFE : ICONS_FULL;
        src.forEach((ch) => {
          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";
          b.textContent = ch;
          b.addEventListener("click", () => insertAtCaret(ch));
          iconGrid.appendChild(b);
        });
      }

      function insertAtCaret(text) {
        pushHistory();
        const s = editor.selectionStart | 0,
          e = editor.selectionEnd | 0;
        const val = editor.value;
        const next = val.slice(0, s) + text + val.slice(e);
        editor.value = next;
        editor.selectionStart = editor.selectionEnd = s + text.length;
        lastEditorValue = next;
        TEXT = next;
        MAP = buildVisibleMap(TEXT);
        ensureStyleLength(MAP.visLen);
        renderAll();
      }

      function countVisibleInSlice(str, a, b) {
        let v = 0,
          i = a;
        while (i < b) {
          if (isLiteralNL(str, i)) {
            i += 2;
            continue;
          }
          if (str[i] === "\n" || str[i] === "\r") {
            i++;
            continue;
          }
          if (isTokenStart(str, i)) {
            const tok = readToken(str, i);
            if (tok && tok.end <= b) {
              i = tok.end;
              continue;
            }
          }
          v++;
          i++;
        }
        return v;
      }

      // Keep styles stable while editing
      let lastEditorValue = "";

      function onEditorInput() {
        const newVal = editor.value;
        const oldVal = lastEditorValue;

        // find splice
        let p = 0;
        while (p < oldVal.length && p < newVal.length && oldVal[p] === newVal[p]) p++;
        let os = oldVal.length - 1,
          ns = newVal.length - 1;
        while (os >= p && ns >= p && oldVal[os] === newVal[ns]) {
          os--;
          ns--;
        }

        const oldMidA = p,
          oldMidB = os + 1;
        const newMidA = p,
          newMidB = ns + 1;

        TEXT = newVal;
        MAP = buildVisibleMap(TEXT);

        const oldRemovedVis = countVisibleInSlice(oldVal, oldMidA, oldMidB);
        const newInsertedVis = countVisibleInSlice(newVal, newMidA, newMidB);

        const oldMap = buildVisibleMap(oldVal);
        const vAtP = oldMap.editToVis[clamp(p, 0, oldVal.length)];

        for (const k of Object.keys(STYLE)) STYLE[k].splice(vAtP, oldRemovedVis);

        const fillIdx = clamp(vAtP - 1, 0, Math.max(0, oldMap.visLen - 1));
        const fill =
          oldMap.visLen === 0 || vAtP === 0
            ? {
                color: normHex(solidColor.value, true),
                b: false,
                i: false,
                u: false,
                size: clamp(parseInt(sizePct.value || "100", 10), 50, 300),
                font: fontSel.value,
                align: "left"
              }
            : {
                color: STYLE.color[fillIdx] || DEFAULTS.color,
                b: !!STYLE.b[fillIdx],
                i: !!STYLE.i[fillIdx],
                u: !!STYLE.u[fillIdx],
                size: STYLE.size[fillIdx] || DEFAULTS.size,
                font: STYLE.font[fillIdx] || DEFAULTS.font,
                align: STYLE.align[fillIdx] || DEFAULTS.align
              };

        for (let i = 0; i < newInsertedVis; i++) {
          STYLE.color.splice(vAtP + i, 0, fill.color);
          STYLE.b.splice(vAtP + i, 0, fill.b);
          STYLE.i.splice(vAtP + i, 0, fill.i);
          STYLE.u.splice(vAtP + i, 0, fill.u);
          STYLE.size.splice(vAtP + i, 0, fill.size);
          STYLE.font.splice(vAtP + i, 0, fill.font);
          STYLE.align.splice(vAtP + i, 0, fill.align);
        }

        ensureStyleLength(MAP.visLen);
        lastEditorValue = newVal;
        renderAll();
      }

      // Apply ops
      function applyToRange(fn) {
        const { vs, ve } = getSelectionVisibleRange();
        if (ve <= vs) {
          setStatus("Select some text first.");
          return false;
        }
        pushHistory();
        for (let v = vs; v < ve; v++) fn(v);
        renderAll();
        return true;
      }

      function toggleFlag(key) {
        const { vs, ve } = getSelectionVisibleRange();
        if (ve <= vs) {
          setStatus("Select some text first.");
          return;
        }
        pushHistory();
        let tr = 0;
        for (let v = vs; v < ve; v++) if (STYLE[key][v]) tr++;
        const setTo = tr < (ve - vs) / 2;
        for (let v = vs; v < ve; v++) STYLE[key][v] = setTo;
        renderAll();
      }

      function applyAlign(mode) {
        applyToRange((v) => (STYLE.align[v] = mode));
        setStatus(`Aligned ${mode}.`);
      }

      // Compact markup builder:
      // - Keep <align><font><size> stable across runs
      // - Only open/close <color> when it changes
      // - b/i/u run-length encoded too
      // - tokens & literal \n are emitted raw and do not consume visible indices
      function buildMarkup() {
        const raw = TEXT.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        const m = buildVisibleMap(raw);
        ensureStyleLength(m.visLen);

        let out = [];
        let vIndex = 0;

        let cur = {
          align: null,
          font: null,
          size: null,
          color: null,
          b: false,
          i: false,
          u: false
        };

        function closeFlags() {
          if (cur.u) {
            out.push("</u>");
            cur.u = false;
          }
          if (cur.i) {
            out.push("</i>");
            cur.i = false;
          }
          if (cur.b) {
            out.push("</b>");
            cur.b = false;
          }
        }

        function closeAll() {
          closeFlags();
          if (cur.color) {
            out.push("</color>");
            cur.color = null;
          }
          if (cur.size != null) {
            out.push("</size>");
            cur.size = null;
          }
          if (cur.font) {
            out.push("</font>");
            cur.font = null;
          }
          if (cur.align) {
            out.push("</align>");
            cur.align = null;
          }
        }

        function openBase(desired) {
          if (cur.align !== desired.align) {
            if (cur.align) out.push("</align>");
            out.push(`<align=${desired.align}>`);
            cur.align = desired.align;
          }
          if (cur.font !== desired.font) {
            if (cur.font) out.push("</font>");
            out.push(`<font="${desired.font}">`);
            cur.font = desired.font;
          }
          if (cur.size !== desired.size) {
            if (cur.size != null) out.push("</size>");
            out.push(`<size=${desired.size}%>`);
            cur.size = desired.size;
          }
        }

        function applyDesired(desired) {
          // If base changes, close color + flags first so nesting stays sane
          const baseChanged = cur.align !== desired.align || cur.font !== desired.font || cur.size !== desired.size;
          if (baseChanged) {
            closeFlags();
            if (cur.color) {
              out.push("</color>");
              cur.color = null;
            }
          }

          openBase(desired);

          // color run
          if (cur.color !== desired.color) {
            closeFlags();
            if (cur.color) out.push("</color>");
            out.push(`<color=${desired.color}>`);
            cur.color = desired.color;
          }

          // flags run
          if (cur.b !== desired.b) {
            out.push(desired.b ? "<b>" : "</b>");
            cur.b = desired.b;
          }
          if (cur.i !== desired.i) {
            out.push(desired.i ? "<i>" : "</i>");
            cur.i = desired.i;
          }
          if (cur.u !== desired.u) {
            out.push(desired.u ? "<u>" : "</u>");
            cur.u = desired.u;
          }
        }

        let i = 0;
        while (i < raw.length) {
          // literal \n
          if (isLiteralNL(raw, i)) {
            if (cleanSlate.checked) closeAll();
            out.push("\\n");
            i += 2;
            continue;
          }
          // actual newline
          if (raw[i] === "\n") {
            if (cleanSlate.checked) closeAll();
            out.push("\\n");
            i++;
            continue;
          }
          // token
          if (isTokenStart(raw, i)) {
            const tok = readToken(raw, i);
            if (tok) {
              out.push(raw.slice(tok.start, tok.end));
              i = tok.end;
              continue;
            }
          }

          // visible char
          const v = vIndex;
          const desired = {
            align: STYLE.align[v] || DEFAULTS.align,
            font: STYLE.font[v] || DEFAULTS.font,
            size: STYLE.size[v] || DEFAULTS.size,
            color: STYLE.color[v] || DEFAULTS.color,
            b: !!STYLE.b[v],
            i: !!STYLE.i[v],
            u: !!STYLE.u[v]
          };

          applyDesired(desired);
          out.push(raw[i]);

          vIndex++;
          i++;
        }

        closeAll();
        return out.join("");
      }

      function toPreviewHTML(markup) {
        let html = markup.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

        // align blocks
        html = html
          .replace(/&lt;align=(left|center|right)&gt;/g, (_, pos) => `<div style="text-align:${pos}">`)
          .replace(/&lt;\/align&gt;/g, "</div>");

        // font
        html = html
          .replace(/&lt;font="([^"]+)"&gt;/g, (_, n) => `<span style="font-family:${FONT_MAP[n.trim()] || "inherit"}">`)
          .replace(/&lt;\/font&gt;/g, "</span>");

        // size
        html = html
          .replace(/&lt;size=(\d{1,3})%&gt;/g, (_, p) => `<span style="font-size:${p}%">`)
          .replace(/&lt;\/size&gt;/g, "</span>");

        // color
        html = html
          .replace(/&lt;color=(#[0-9A-Fa-f]{6})&gt;/g, (_, h) => `<span style="color:${h}">`)
          .replace(/&lt;\/color&gt;/g, "</span>");

        // b/i/u
        html = html
          .replace(/&lt;b&gt;/g, "<b>")
          .replace(/&lt;\/b&gt;/g, "</b>")
          .replace(/&lt;i&gt;/g, "<i>")
          .replace(/&lt;\/i&gt;/g, "</i>")
          .replace(/&lt;u&gt;/g, "<u>")
          .replace(/&lt;\/u&gt;/g, "</u>");

        // line breaks
        html = html.replace(/\\n/g, "<br/>").replace(/\n/g, "<br/>");
        return html;
      }

      function renderAll() {
        MAP = buildVisibleMap(TEXT);
        ensureStyleLength(MAP.visLen);

        const markup = buildMarkup();
        output.textContent = markup;
        preview.innerHTML = toPreviewHTML(markup);
      }

      function normalizeOutput() {
        sizePct.value = clamp(parseInt(sizePct.value || "100", 10), 50, 300);
        solidColor.value = normHex(solidColor.value, true);
        renderAll();
        setStatus("Normalized.");
      }

      function applyGradient() {
        const { vs, ve } = getSelectionVisibleRange();
        if (ve <= vs) {
          setStatus("Select text for gradient.");
          return;
        }
        pushHistory();

        const len = ve - vs;
        if (len === 1) {
          STYLE.color[vs] = STOPS[Math.floor(STOPS.length / 2)];
        } else {
          for (let i = 0; i < len; i++) {
            const t = i / (len - 1);
            const seg = (STOPS.length - 1) * t;
            const i0 = Math.floor(seg);
            const i1 = Math.min(STOPS.length - 1, i0 + 1);
            const localT = seg - i0;
            STYLE.color[vs + i] = normHex(lerpColor(STOPS[i0], STOPS[i1], localT), true);
          }
        }
        renderAll();
        setStatus("Gradient applied.");
      }

      function resetLine() {
        const old = applyLine.checked;
        applyLine.checked = true;
        const { vs, ve } = getSelectionVisibleRange();
        applyLine.checked = old;

        if (ve <= vs) {
          setStatus("Nothing on this line.");
          return;
        }
        pushHistory();
        const base = normHex(solidColor.value, true);
        const sz = clamp(parseInt(sizePct.value || "100", 10), 50, 300);
        const f = fontSel.value;

        for (let v = vs; v < ve; v++) {
          STYLE.color[v] = base;
          STYLE.b[v] = false;
          STYLE.i[v] = false;
          STYLE.u[v] = false;
          STYLE.size[v] = sz;
          STYLE.font[v] = f;
          STYLE.align[v] = "left";
        }
        renderAll();
        setStatus("Line reset.");
      }

      function downloadText(filename, text) {
        const blob = new Blob([text], { type: "text/plain;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }

      // Events
      editor.addEventListener("input", onEditorInput);

      applySolidBtn.addEventListener("click", () => {
        const hex = normHex(solidColor.value, true);
        if (applyToRange((v) => (STYLE.color[v] = hex))) setStatus("Solid applied.");
      });

      applyFontBtn.addEventListener("click", () => {
        const f = fontSel.value;
        if (applyToRange((v) => (STYLE.font[v] = f))) setStatus("Font applied.");
      });

      applySizeBtn.addEventListener("click", () => {
        const s = clamp(parseInt(sizePct.value || "100", 10), 50, 300);
        sizePct.value = s;
        if (applyToRange((v) => (STYLE.size[v] = s))) setStatus("Size applied.");
      });

      btnB.addEventListener("click", () => toggleFlag("b"));
      btnI.addEventListener("click", () => toggleFlag("i"));
      btnU.addEventListener("click", () => toggleFlag("u"));

      btnNL.addEventListener("click", () => insertAtCaret("\\n"));

      btnUndo.addEventListener("click", undo);
      btnRedo.addEventListener("click", redo);

      document.querySelectorAll("[data-align]").forEach((b) => {
        b.addEventListener("click", () => applyAlign(b.getAttribute("data-align")));
      });

      resetLineBtn.addEventListener("click", resetLine);

      insertTokenBtn.addEventListener("click", () => insertAtCaret(tokenSel.value));

      toggleIconsBtn.addEventListener("click", () => {
        const open = !iconPalette.classList.contains("open");
        iconPalette.classList.toggle("open", open);
        if (open) buildIcons();
      });
      safeIcons.addEventListener("change", () => iconPalette.classList.contains("open") && buildIcons());

      clearStylesBtn.addEventListener("click", () => {
        const base = normHex(solidColor.value, true);
        const sz = clamp(parseInt(sizePct.value || "100", 10), 50, 300);
        const f = fontSel.value;
        if (
          applyToRange((v) => {
            STYLE.color[v] = base;
            STYLE.b[v] = false;
            STYLE.i[v] = false;
            STYLE.u[v] = false;
            STYLE.size[v] = sz;
            STYLE.font[v] = f;
            STYLE.align[v] = "left";
          })
        )
          setStatus("Selection cleared.");
      });

      normalizeBtn.addEventListener("click", normalizeOutput);

      addStopBtn.addEventListener("click", () => {
        if (STOPS.length >= 10) return;
        pushHistory();
        STOPS.push(randHex());
        renderStops();
        setStatus("Stop added.");
      });

      remStopBtn.addEventListener("click", () => {
        if (STOPS.length <= 2) return;
        pushHistory();
        STOPS.pop();
        renderStops();
        setStatus("Stop removed.");
      });

      randStopsBtn.addEventListener("click", () => {
        pushHistory();
        STOPS = STOPS.map(() => randHex());
        renderStops();
        setStatus("Stops randomized.");
      });

      stopsEl.addEventListener("input", (e) => {
        const row = e.target.closest(".stop-row");
        if (!row) return;
        const idx = [...stopsEl.children].indexOf(row);
        const [hexInput, colorInput] = row.querySelectorAll("input");
        if (e.target === hexInput) {
          const h = normHex(hexInput.value, true);
          hexInput.value = h;
          colorInput.value = h;
          STOPS[idx] = h;
        } else if (e.target === colorInput) {
          const h = normHex(colorInput.value, true);
          hexInput.value = h;
          STOPS[idx] = h;
        }
        updateGradPreview();
      });

      stopsEl.addEventListener("click", (e) => {
        const btn = e.target.closest("button");
        if (!btn) return;
        const i = parseInt(btn.dataset.idx, 10);
        if (btn.classList.contains("stop-del") && STOPS.length > 2) {
          pushHistory();
          STOPS.splice(i, 1);
        } else if (btn.classList.contains("stop-up") && i > 0) {
          pushHistory();
          [STOPS[i - 1], STOPS[i]] = [STOPS[i], STOPS[i - 1]];
        } else if (btn.classList.contains("stop-down") && i < STOPS.length - 1) {
          pushHistory();
          [STOPS[i + 1], STOPS[i]] = [STOPS[i], STOPS[i + 1]];
        }
        renderStops();
      });

      applyGradientBtn.addEventListener("click", applyGradient);

      copyMarkupBtn.addEventListener("click", () => {
        copyToClipboard(buildMarkup()).then(() => setStatus("Copied."));
      });

      downloadTxtBtn.addEventListener("click", () => {
        downloadText("template.txt", buildMarkup());
        setStatus("Downloaded template.txt");
      });

      // Boot
      (function init() {
        // show popup unless disabled
        if (!localStorage.getItem("maul_beta_modal_hide")) openModal();

        TEXT = "♡Welcome to my lobby♡\\n";
        editor.value = TEXT;
        lastEditorValue = TEXT;

        MAP = buildVisibleMap(TEXT);
        ensureStyleLength(MAP.visLen);

        const base = normHex(solidColor.value, true);
        const sz = clamp(parseInt(sizePct.value || "100", 10), 50, 300);
        const f = fontSel.value;

        for (let v = 0; v < MAP.visLen; v++) {
          STYLE.color[v] = base;
          STYLE.size[v] = sz;
          STYLE.font[v] = f;
          STYLE.align[v] = "left";
          STYLE.b[v] = false;
          STYLE.i[v] = false;
          STYLE.u[v] = false;
        }

        renderStops();
        renderAll();
      })();
    </script>
  </body>
</html>
